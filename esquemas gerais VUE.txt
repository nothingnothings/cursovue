
estrutura básica

Vue.createApp(
  {
    ///a data com a qual você trabalhará e referenciará por meio das DIRECTIVES no html
    data() {
      return {
        goals: [],
        enteredValue: ''
      }
    },

    methods: {

    }
  }
)







ESTRUTURA BÁSICA AVANÇADA:








export default {


    data() {
        return {

        }
    },


    computed: {},

    watch: {},
    
    methods: {},

    props: {},

    emits: {

    },

    provide (OU INJECT): {

    }
}












const app = Vue.createApp(
    {
    ///a data com a qual você trabalhará e referenciará por meio das DIRECTIVES no html
        data() {
            return {
                counter: 0,
		goals: [],
		enteredValue: '',
                name: '',
                fullName2: ''
            }
        },
	////SEUS WATCHERS
        watch: 
        ,

	///as computed properties, que são tipo methods que AGEM COMO PROPRIEDADES, e que DEPENDEM DE MUDANÇAS EM SUAS DEPENDENCIES PARA SEREM EXECUTADAS E OUTPUTTAR CONTEÚDO
        computed: {
            nomeDaPropriedade() {
                return this.name;  //'this.name' é a dependency, nesse caso...
            }
        },

    ///os methods que vocÊ chamará no código html A PARTIR DE EVENTS/ a partir de quaisquer mudanças nas suas DATA PROPERTIES
        methods: {
            nomeDoMethod() {

            }
        }
    }
)





 









////////////////////////////


SINTAXE HANDLEBARS, PARA OUTPUTTAR DATA (similar ao handlebars):



JS:



const app = Vue.createApp({ ////podemos armazenar nossa VUE INSTANCE EM UMA CONSTANTE, SIM....

    data() {
        return {
            courseGoal: 'Finish the Fight.'
        }
    }
})




HTML:

    <section id="user-goal">
        <h2>My Course Goal</h2>
        <p>{{ courseGoal }}</p>
    </section>








OBS::: ESSA SINTAXE DE STRING INTERPOLATION __ SÓ __ FICA DISPONÍVEL __ NO MEIO _ 

DE OPENING E CLOSING HTML TAGS (ou seja, não pode ser usada em attributes como "href" em anchor tags, por exemplo")


SE VOCê DESEJA_ PASSAR 1 VALUE DINAMICO A 1 ATTRIBUTE COM O VUE,

_ USE__ 'v-bind', que é específico para isso...



///////////////////////////////





DIRECTIVES PRINCIPAIS:



///////////////////////////////////////////

v-model --> usado para INPUT FIELDS e two-way binding, pelo que entendi.









EX:


O CÓDIGO ''COMPLETO'', SEM SHORTHAND, É ASSIM:




<input type="text" v-bind:value="name" v-on:input="setName" />   <-----------------------------
<button v-on:click="resetInput">Reset Input</button>





O CÓDIGO __ COM SHORTHAND, com o 'v-model', É ASSIM:
(tiramos o 'v-bind' e o 'v-on:input'...)




<input type="text" v-model="name" />
<button v-on:click="resetInput">Reset Input</button>














(

ESSA DIRECTIVE É USADA QUANDO VOCÊ QUER COISAS COMO 

''1 BUTTON QUE FAZ A DATA PROPERTY VINCULADA AO INPUT FIELD E A DATA DO INPUT FIELD SEREM 

LIMPAS _ AUTOMATICAMENTE, AO MESMO TEMPO'',


e quando você quer que cada UPDATE DO VALUE NO INPUT FIELD 


UPDATE TAMBÉM O DATA FIELD no app vue, e vice-versa..

)







/////////////////////////////////////////////



///////////////////////////////////////////////

v-on:nomeDoEvent="nomeDoMethod" --> usado para QUALQUER COISA QUE VOCê IMAGINAR... (desde buttons, até outros elementos...) --> esse 'v-on' vai DISPARAR O METHOD especificado em 'nomeDoMethod' sempre que AQUELE EVENT ESPECIFICADO POR VOCÊ OCORRER...

ex:

v-on:click="nomeDoMethod"

////////////////////////////////////////////////





/////////////////////////////////////

v-for  ----------> É USADO _ PARA _ 


FAZER O OUTPUT DE COISAS COMO 'LISTS';




OU SEJA,

__ ELE __ VAI _CRIAR ELEMENTOS A PARTIR _ DE ARRAYS QUE VOCê TIVER NA PROPRIEDADE 'data'...








tipo assim:




temos um array no vue,

'goals',






e fica assim no html, com a directive:




    <ul>
      <!-- OBS: AQUI MOSTRA-SE COMO __ FAZER O OUTPUT _ DE MÚLTIPLOS ELEMENTOS, A PARTIR DE UM ARRAY DE elementos lá no object Vue, em 'data'...-->
      <!-- A SINTAXE DO HANDLEBARS NOS PERMITE GANHAR ACESSO À VARIÁVEL 'goal', que representa cada 1 dos elementos no array 'goals'...-->
      <li v-for="goal in goals">{{goal}}</li>
    </ul>
  </div>







-> COM ISSO, SERÁ CRIADO 1 ELEMENTO '<li>' para (FOR) cada um dos elementos no array 'goals'...








////////////////////////////////////////////////////////////






DIRECTIVE USADA PARA 'OUTPUTTAR HTML RAW',



o 


'v-html'... -->  É USADO PARA OUTPUTTAR HTML ARMAZENADO NO SEU VUE APP...







--> a escrita é tipo assim (call de um method que retorna HTML, por exemplo) :



        <p v-html="outputGoal3HTMLVersion()"></p>



ou assim (referencia a uma propriedade que segura um HTML, no app VUE):
 

        <p v-html="courseGoal3"></p>






/////////////////////////////////////////////////////////









OUTRA DIRECTIVE MUITO IMPORTANTE, 'v-on' ---> 




v-on ---->  HÁ UMA SHORTHAND, QUE É ASSIM:
 


@click="xxxx" 

@input="yyyy"


(EM VEZ DE ESCREVER "v-on:click="xxxxx" "


ESSA DIRECTIVE 




É USADA PARA _ DEFINIR EVENT LISTENERS LÁ NO SEU CÓDIGO HTML,


vinculados a methods definidos no seu VUE APP..






--> a sintaxe é tipo assim (exemplo de click listener) --->








<button v-on:click="nomeDoMethod">BOTAO</button>


OU (inline javascript) :






const app = Vue.createApp({
  data() {
    return {
      counter: 0,
    };




<button v-on:click="counter++">BOTAO</button>



DO LADO DIREITO DO ':', 

VOCÊ COLOCA O EVENT A QUE VOCÊ QUER 'LISTEN TO'...



//////////////////////////////












TIPOS DE MODIFIERS:










1) GENERAL EVENT MODIFIERS ----> 


ex:


 <form v-on:submit.prevent="formSubmitHandlerEleganteComEventModifier">


2) CLICK EVENT MODIFIERS ---->



ex (RIGHT-CLICK MODIFIER): 

        <button v-on:click.right="addToCounterDynamic(5)">Add 5 with right click </button>





3) KEYBOARD EVENT MODIFIERS --> 


ex ('keyup' modifier; faz com que AQUELE METHOD SÓ SEJA DISPARADO SE A KEY DE ENTER TIVER SIDO PRESSIONADA):



              <!-- EXEMPLO DE EVENT MODIFIER DO EVENTO 'INPUT', INPUT EVENT MODIFIERS. AQUI, APENAS 'enter' será a key que disparará esse method -->
        <input type="text" v-on:input="inputChangedHandlerSpecial" v-on:keyup.enter="inputChangedHandlerConfirmed">
            <p>Confirmed Name: {{ confirmedName }}</p>









outros modifiers de key possíveis:


keyup.shift 

keyup.ctrl
 

keyup.a 


etc etc...








//////////////////////////////////////////////






OUTRA DIRECTIVE,



'v-once': 





BEM, PODE SER QUE TENHAMOS ALGO COMO ISTO:







<p>Starting Counter Value: {{ counter }}</p>










--> QUEREMOS QUE 



__ ESSA PROPRIEDADE FIQUE COM O VALUE DE 'counter' inicial, e que nunca mude...







---> QUEREMOS GARANTIR QUE O VALUE DE 'STARTING COUNTER' nunca mude... 






--> PARA ISSO, 

SE VOCÊ TIVER UM CENÁRIO EM QUE: 



1) VOCÊ TEM UMA DATA QUE MUDA AO LONGO DO TEMPO 




2) EM QUE VOCÊ QUER PRESERVAR O VALUE INICIAL DESSA DATA EM ALGUM LOCAL DE SUA PÁGINA...




EM CASOS COMO ESSES, VOCÊ PODE USAR A DIRECTIVE DE 'v-once' ------> 








A ESCRITA É ESTA:



<p v-once>Starting Counter Value: {{ counter }}</p>




--> O 'v-once'
 
 BASICAMENTE DECRETA AO  VUE QUE 

  

  ''QUALQUER DYNAMIC DATA-BINDING QUE OCORRER NESSE ELEMENT __ DEVERÁ _ SER 

  EVALUATED __ APENAS _ 


  1 ÚNICA VEZ'''... changes posteriores NÃO SERÃO REFLETIDAS...









//////////////////////////////////////////////////////////





OUTRAS DIRECTIVES SUPER _ IMPORTANTES__... .:













v-if ----> USADA PARA RENDERIZAR CONTEÚDO CONDICIONALMENTE (similar a ngIf)



EXEMPLO V-IF:





        <!-- SEM V-IF -->
        <!-- <p>No goals have been added yet - please add some!</p> -->

        <!--- COM V-IF -->
        <p v-if="goals.length === 0">No goals have been added yet - please add some!</p>










v-else ---> TAMBÉM USADO PARA ESSE PROPÓSITO 



<p v-if="goals.length === 0">No goals</p>

<ul v-else-if="goals.length > 0">




v-else-if --> TAMBÉM USADO PARA ESSE PROPÓSITO





<p v-if="goals.length === 0">No goals</p>

<ul v-else-if="goals.length > 0">

<p v-else>Something weird with our goals....</p>






///////////////////////////////////////////////////////////////////////////////////







v-show ---> É UMA DIRECTIVE QUE SÓ FUNCIONA DE FORMA 'standalone', ou seja, __ NÃO FUNCIONA EM COMBINAÇÃO COM O 'v-if', 'v-else' e 'v-else-if'...


ISSO QUER DIZER QUE SE VOCÊ TIVER MÚLTIPLAS 'ALTERNATIVAS/CONDITIONS' no seu código, você precisará escrever múltiplos 'v-show', em todos os elementos...





<p v-show="goals.length === 0">No Goals</p>

<ul v-show="goals.length > 0">
    <li>Goal</li>
</ul>






--> O V-SHOW não vai remover o elemento do DOM, mas vai definir seu display style como 'none'...









--> SHOW E HIDE DE ELEMENTS COM O CSS --> ISSO QUER DIZER QUE 

VOCÊ NÃO PRECISA ADICIONAR E REMOVER ELEMENTOS, O QUE 

ECONOMIZA PERFORMANCE...








------> ENTRETANTO,

O USO DE APENAS 'v-show'

para esconder MAS _ MANTER_ ESSES ELEMENTOS_ __

NO DOM __ 


TAMBÉM TE DEIXA COM VÁRIOS ELEMENTOS RENDERIZADOS NA TELA, O QUE TAMBÉM NÃO É IDEAL...












É POR ISSO QUE, COMO 'RULE OF THUMB', 




vocÊ TIPICAMENTE DEVE USAR 'v-if'


E 
APENAS 'FALLBACK' ao 'v-show'


SE _ VOCÊ TIVER _ UM 


ELEMENTO CUJA 



'VISIBILITY STATUS' MUDA  __ UM MONTE___.... --> 
















OU SEJA, EXEMPLOS COMO 'um bottão que toggla um elemento on/off' (aí você coloca o v-show, pra n impactar isso aí, esse render desnecessário)...








///////////////////////////////////////////////////////////////////////////







V-FOR ---- É UMA DIRECTIVE USADA PARA COISAS COMO 'OUTPUT LISTS' (vários list items, coisas repetidas, for of loop, etc)....














PARA __ CONSEGUIR USAR O 'v-for',


PRECISAMOS DEFINIR SEU VALUE QUASE COMO SE FOSSE UM FOR LOOP,
TIPO ASSIM:










<li v-for="goal in goals"></li>










( OU SEJA, IMITAMOS A ESCRITA DE 'const goal of goals' ... ) 








--> AQUI USAMOS __ 'goal in goals'...





--> A ESCRITA DE 'goal of goals'

TAMBÉM É SUPORTADA PELO VUE,

mas AQUI DEVEMOS USAR 'goal in goals'... (e não 'goal of goals').











--> SINTAXE ALTERNATIVA (que consegue o 'index' do item no array):






<li v-for="(goal, index) in goals"></li>












--> SINTAXE USADA COM OBJECTS, E NÃO COM ARRAYS (sintaxe mais rara):






        <!-- EXEMPLO DE LOOPS NO VUE, mas POR DENTRO DE OBJECTS (BTW, o 'index' é raramente utilizado) -->
        <ul>
            <li v-for="(propertyValue, keyName, indexNumber) in exampleObject">Value: {{propertyValue}} Name of the key: {{ keyName}} Index: {{indexNumber}}</li>

        </ul>











///////////////////////////////////////////////////////////








OUTRA DIRECTIVE IMPORTANTE, A SER USADA COM 'v-for', QUE AGE COMO O PROP DE 'key' (que distinguia os elementos) em ELEMENTOS RENDERIZADOS COM 'map', lá no 'React',

que 

é 








A DIRECTIVE/ATTRIBUTE DE 



'key' (exatamente como no react)...










--> MAS KEY É FREQUENTEMENTE UTILIZADO COM __ DATA BINDING, BINDING DE ATTRIBUTES, NA VERDADE, TIPO ASSIM: 




':key'...



(pq queremos que ele seja realmente unique, dinâmico)...




OBS: USAR 'INDEX' como key NÃO É UMA BOA IDEIA, NO VUE, POR CAUSA DA REUTILIZAÇÃO DE elementos (list items)...



NESTE EXEMPLO USAMOS 'goal' (a string de cada goal) como index, mas também não é bom, 

pq 
O VALUE DAS STRINGS PODE SE REPETIR (usuário inputta 2 inputs iguais)... em um app de verdade, como no react, você terá IDS de verdade, extraídos de uma database,
para compor 

essa 'key' em cada list  item...



ex:




        <ul>
            <li v-for="(goal, index) in goals" @click="removeGoal(index)" :key="goal">
                <p>
                    Goal: {{ goal }} Index: {{ index }}
                </p>
                <!-- o modifier de 'stop' IMPEDE A PROPAGATION DESSE EVENT DE 'CLICK' para o parent element, que REMOVERIA ESSA LI (com o input field) de nosso DOM-->
                <input type="text" @click.stop >
            </li>
        </ul>











OUTRO DETALHE:






-------> E SE VOCÊ PRECISA DE 'V-FOR' E 'V-IF'



AO MESMO TEMPO,

 _ NÃO _ USE _OS 
 2 EM 1 MESMO ELEMENTO... --> USE 1 WRAPPER COM 'V-IF',
 EM VEZ DISSO....











//////////////////////////////////////







REF ATTRIBUTE --> É UM ATTRIBUTE NON-DEFAULT, COMO 'key'...








SUA UTILIZAÇÃO É A SEGUINTE:








    <section id="app4">
        <!-- <input type="text" @input="saveInput"> -->
        <!-- 'ref' é usado nos cases em que vocÊ APENAS QUER PEGAR O 'USER INPUT' uma única vez, e não 'once for every keystroke'...-->
        <input type="text" ref="userText">
        <button @click="setText">
            Set Text
        </button>
        <p>{{ message }}</p>
    </section>













--> utilize se você não quer ter 'VALIDATION ON EVERY KEYSTROKE' ou algo assim..









OBS: Os 'refs' PODEM SER USADOS NÃO SÓ EM 'input elements', mas em QUAISQUER ELEMENTOS HTML...






ex:








--> O VUE BASICAMENTE 'MEMORIZA'


QUE VOCÊ QUER ACESSO 

AO INPUT ELEMENT...






--> AÍ VOCÊ ACESSA, LÁ NO JAVASCRIPT VUE APP,


esse elemento, por meio da escrita 'this.$refs.xxxxx'.. (como 'this.$refs.userText', nesse exemplo desse html/template)...
















///////////////////////////////////////




OUTRO RECURSO DO VUE,


(VER AULA 'EMITINDO CUSTOM EVENTS' (CHILD -> PARENT), lá no módulo 8....


'$this.emit()'  --> É USADO, NO SEU '<script></script>', PARA FAZER A COMUNICAÇÃO NO SENTIDO INVERSO ('child' -> 'parent')... VOCÊ FAZ EMIT DE 1 EVENT LÁ NO SEU CHILD COMPONENT, QUE ENTÃO É CAPTADO PELO PARENT QUE SEGURA ESSE CHILD COMPONENT... (E com isso podemos TRANSMITIR DATA)...







////////////////////////////////////








SCOPED STYLES:
















----> CERTO... MAS, ENTÃO, 

COMO PODEMOS 

DEFINIR UM 'SCOPED STYLE',



STYLE SCOPADO A 1 COMPONENT ESPECÍFICO?












boa pergunta....











---> PARA SCOPAR STYLES A 1 COMPONENT ESPECÍFICO, TEMOS QUE SEGUIR UM APPROACH DIFERENTE..










---> PROVAVELMENTE DEVEMOS DEFINIR 

O STYLE DESSES NEGÓCIOS EM 1 ARQUIVO SEPARADO..













--> O PROFESSOR DIZ QUE ÀS VEZES O STYLE GLOBAL É O QUE VOCê VAI QUERER,

COMO EM 'App.vue' ( estilos que você quer que sejam aplicados ao app inteiro são geralmente colocados ali)...
















MAS, EM INDIVIDUAL COMPONENTS, SERIA NICE SE PUDÉSSEMOS 'SCOPE'


ESSES STYLES A CADA COMPONENT,

PARA QUE 
APENAS 

AFETEM 

O 

TEMPLATE 

DO 


COMPONENT EM QUE ESTÃO POSICIOANDOS..










--> E O __ VUE__ SUPORTA__ ESSA FEATURE...












--> PARA __ ATIVAR_ A FEATURE __de 'scoped styles',



VOCê DEVE DEFINIR O ATTRIBUTE DE 'scoped'

LÁ 

NA SUA STYLE TAG,

TIPO ASSIm (exemplo de 'header'):















<template>

    <header>
        <h1>More on Vue Components</h1>
    </header>
</template>



<script>


export default {


    data() {
        return {

        }
    }
}
</script>





<style scoped> 
header {
    /* 'scoped' É O ATTRIBUTE QUE VOCê COLOCA NA TAG DE 'STYLE', SE VOCê DESEJA QUE ESSES STYLES DEFINIDOS AQUI __ SEJAM __ SCOPADOS APENAS A ESSE COMPONENT EM SI (ou seja, não serão repassados ao app inteiro)... */
    width: 100%;
    height: 5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    background-color: #14005e;
}

header h1 {
    color: white;
    margin: 0;
}
</style>





























--> SE VOCÊ ADICIONA ISSO,

VOCÊ 

DIZ AO VUE QUE 


VOCÊ 

NÃO QUER QUE ESSES STYLES SEJAM REPASSADOS 

AOS 

CHILD COMPONENTS,

E NEM 




MESMO AOS SIBLING COMPONENTS..











---> OK... ISSO É BOM PARA SETORIZAR OS STYLES,

MAS VOCÊ DEVE TER EM MENTE AQUELE DETALHE,


DE QUE 



'''OS STYLES NÃO SÃO APLICADOS A CHILD COMPONENTS,

NEM SIBLING COMPONENTS'..










------> CERTO..











--> CERTO.... PODEMOS USAR ESSA OPTION, COM CERTEZA....










-------------------------------------------




///////////////////////////////////////










OUTRA FEATURE, OS 'SLOTS' (são wrappers/adhoc components) 









ex:
















--> PARA USAR SEU COMPONENT COMO 'WRAPPER/SLOT',




VOCÊ 

DEVE 

IR ATÉ O COMPONENT QUE SERÁ USADO COMO WRAPPER (nesse nosso caso, 'BaseCard'),






E AÍ __ VOCÊ VAI TIRAR A KEY DE 'props',

PQ 
AGORA 


VOCê VAI USAR 



UM __ ELEMENTO HTML/VUE 




ESPECIAL,

QUE É 
O 


'<slot>'..






EX:















<template>
    <!-- ESTE É UM COMPONENT QUE SERÁ USADO COMO 'slot', ou seja, COMO COMPONENT QUE ENVELOPA OUTROS COMPONENTS... É UM HOC/WRAPPER -->
    <div></div>
</template>


<style scoped>
div {
    margin: 2rem auto;
    max-width: 30rem;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
    padding: 1rem;
}
</style>








EX:














<template>
    <!-- ESTE É UM COMPONENT QUE SERÁ USADO COMO 'slot', ou seja, COMO COMPONENT QUE ENVELOPA OUTROS COMPONENTS... É UM HOC/WRAPPER -->
    <div>
        <slot></slot>
    </div>
</template>


<style scoped>
div {
    margin: 2rem auto;
    max-width: 30rem;
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.26);
    padding: 1rem;
}
</style>















--> E SE FAZEMOS ISSO  E SALVAMOS O CÓDIGO,




VEREMOS _ QUE _ TERÁ FUNCIONADO,

E QUE 

AGORA TEREMOS O LOOK DESEJADO POR NÓS...












--> QUER DIZER QUE '<slot></slot>'


É A  __ MESMA __ COISA QUE 

'{props.children}' 




EM UM COMPONENT REACT,

POR EXEMPLO....







